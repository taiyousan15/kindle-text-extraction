"""
T-Max Work3 Infrastructure as Code Agent
ã‚¤ãƒ³ãƒ•ãƒ©æ§‹æˆç®¡ç†ãƒ»è‡ªå‹•ãƒ—ãƒ­ãƒ“ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°ãƒ»ãƒ‰ãƒªãƒ•ãƒˆæ¤œçŸ¥ã‚’æ‹…å½“

æ©Ÿèƒ½:
- Terraform/Pulumiçµ±åˆ
- ã‚¤ãƒ³ãƒ•ãƒ©æ§‹æˆãƒ•ã‚¡ã‚¤ãƒ«è‡ªå‹•ç”Ÿæˆ
- ç’°å¢ƒå·®åˆ†æ¤œå‡º
- ãƒ‰ãƒªãƒ•ãƒˆæ¤œçŸ¥
- ã‚³ã‚¹ãƒˆæœ€é©åŒ–ææ¡ˆ
"""
import os
import subprocess
import json
import yaml
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
from datetime import datetime
import sys

# Add parent directory to path
sys.path.append(str(Path(__file__).parent.parent.parent))

from tmax_work3.blackboard.state_manager import (
    Blackboard,
    AgentType,
    TaskStatus,
    get_blackboard
)


class InfrastructureAsCodeAgent:
    """
    Infrastructure as Code Agent - IaCã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ

    å½¹å‰²:
    - Terraform/Pulumiè¨­å®šã®ç®¡ç†
    - ã‚¤ãƒ³ãƒ•ãƒ©æ§‹æˆã®è‡ªå‹•ç”Ÿæˆ
    - ç’°å¢ƒé–“ã®å·®åˆ†æ¤œå‡º
    - ãƒ‰ãƒªãƒ•ãƒˆæ¤œçŸ¥ã¨ä¿®æ­£
    - ã‚³ã‚¹ãƒˆæœ€é©åŒ–ææ¡ˆ
    """

    def __init__(self, repository_path: str):
        self.repo_path = Path(repository_path)
        self.blackboard = get_blackboard()
        self.terraform_dir = self.repo_path / "terraform"
        self.pulumi_dir = self.repo_path / "pulumi"
        self.configs_dir = self.repo_path / "infrastructure"
        self.reports_dir = self.repo_path / "tmax_work3" / "data" / "iac_reports"

        # ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
        self.terraform_dir.mkdir(parents=True, exist_ok=True)
        self.configs_dir.mkdir(parents=True, exist_ok=True)
        self.reports_dir.mkdir(parents=True, exist_ok=True)

        # IaCãƒ„ãƒ¼ãƒ«æ¤œå‡º
        self.iac_tool = self._detect_iac_tool()

        # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²
        self.blackboard.register_agent(
            AgentType.INFRASTRUCTURE_AS_CODE,
            worktree="main"
        )

        self.blackboard.log(
            f"ğŸ—ï¸ Infrastructure as Code Agent initialized (tool: {self.iac_tool})",
            level="INFO",
            agent=AgentType.INFRASTRUCTURE_AS_CODE
        )

    def _detect_iac_tool(self) -> str:
        """ä½¿ç”¨ä¸­ã®IaCãƒ„ãƒ¼ãƒ«ã‚’æ¤œå‡º"""
        # Terraformãƒã‚§ãƒƒã‚¯
        if (self.terraform_dir / "main.tf").exists():
            return "terraform"

        # Pulumiãƒã‚§ãƒƒã‚¯
        if (self.pulumi_dir / "Pulumi.yaml").exists():
            return "pulumi"

        # ã‚³ãƒãƒ³ãƒ‰ã®å­˜åœ¨ç¢ºèª
        try:
            subprocess.run(["terraform", "version"], capture_output=True, timeout=10)
            return "terraform"
        except:
            pass

        try:
            subprocess.run(["pulumi", "version"], capture_output=True, timeout=10)
            return "pulumi"
        except:
            pass

        return "none"

    def generate_terraform_config(self, resources: Dict[str, Any]) -> Tuple[bool, str]:
        """
        Terraformè¨­å®šã‚’ç”Ÿæˆ

        Args:
            resources: ã‚¤ãƒ³ãƒ•ãƒ©ãƒªã‚½ãƒ¼ã‚¹å®šç¾©

        Returns:
            (success, config_path)
        """
        self.blackboard.log(
            "ğŸ“ Generating Terraform configuration...",
            level="INFO",
            agent=AgentType.INFRASTRUCTURE_AS_CODE
        )

        try:
            # main.tfç”Ÿæˆ
            main_tf_content = self._build_terraform_main(resources)
            main_tf_path = self.terraform_dir / "main.tf"
            main_tf_path.write_text(main_tf_content)

            # variables.tfç”Ÿæˆ
            variables_tf_content = self._build_terraform_variables(resources)
            variables_tf_path = self.terraform_dir / "variables.tf"
            variables_tf_path.write_text(variables_tf_content)

            # outputs.tfç”Ÿæˆ
            outputs_tf_content = self._build_terraform_outputs(resources)
            outputs_tf_path = self.terraform_dir / "outputs.tf"
            outputs_tf_path.write_text(outputs_tf_content)

            self.blackboard.log(
                f"âœ… Terraform config generated: {self.terraform_dir}",
                level="SUCCESS",
                agent=AgentType.INFRASTRUCTURE_AS_CODE
            )

            return True, str(self.terraform_dir)

        except Exception as e:
            self.blackboard.log(
                f"âŒ Terraform config generation failed: {str(e)}",
                level="ERROR",
                agent=AgentType.INFRASTRUCTURE_AS_CODE
            )
            return False, str(e)

    def _build_terraform_main(self, resources: Dict[str, Any]) -> str:
        """Terraform main.tfã‚’æ§‹ç¯‰"""
        content = """# Generated by T-Max Work3 Infrastructure as Code Agent

terraform {
  required_version = ">= 1.0"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region
}

"""

        # EC2ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
        if "ec2_instances" in resources:
            for instance in resources["ec2_instances"]:
                content += f"""
resource "aws_instance" "{instance['name']}" {{
  ami           = var.ami_id
  instance_type = "{instance.get('type', 't2.micro')}"

  tags = {{
    Name        = "{instance['name']}"
    Environment = var.environment
    ManagedBy   = "terraform"
  }}
}}

"""

        # RDSãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
        if "rds_databases" in resources:
            for db in resources["rds_databases"]:
                content += f"""
resource "aws_db_instance" "{db['name']}" {{
  identifier        = "{db['name']}"
  engine            = "{db.get('engine', 'postgres')}"
  engine_version    = "{db.get('version', '15.0')}"
  instance_class    = "{db.get('instance_class', 'db.t3.micro')}"
  allocated_storage = {db.get('storage', 20)}

  db_name  = var.db_name
  username = var.db_username
  password = var.db_password

  skip_final_snapshot = true

  tags = {{
    Name        = "{db['name']}"
    Environment = var.environment
  }}
}}

"""

        # S3ãƒã‚±ãƒƒãƒˆ
        if "s3_buckets" in resources:
            for bucket in resources["s3_buckets"]:
                content += f"""
resource "aws_s3_bucket" "{bucket['name']}" {{
  bucket = "{bucket['name']}"

  tags = {{
    Name        = "{bucket['name']}"
    Environment = var.environment
  }}
}}

"""

        return content

    def _build_terraform_variables(self, resources: Dict[str, Any]) -> str:
        """Terraform variables.tfã‚’æ§‹ç¯‰"""
        content = """# Terraform Variables

variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}

variable "environment" {
  description = "Environment name"
  type        = string
  default     = "production"
}

variable "ami_id" {
  description = "AMI ID for EC2 instances"
  type        = string
}

variable "db_name" {
  description = "Database name"
  type        = string
}

variable "db_username" {
  description = "Database username"
  type        = string
  sensitive   = true
}

variable "db_password" {
  description = "Database password"
  type        = string
  sensitive   = true
}
"""
        return content

    def _build_terraform_outputs(self, resources: Dict[str, Any]) -> str:
        """Terraform outputs.tfã‚’æ§‹ç¯‰"""
        content = """# Terraform Outputs

"""

        if "ec2_instances" in resources:
            for instance in resources["ec2_instances"]:
                content += f"""
output "{instance['name']}_public_ip" {{
  description = "Public IP of {instance['name']}"
  value       = aws_instance.{instance['name']}.public_ip
}}

"""

        if "rds_databases" in resources:
            for db in resources["rds_databases"]:
                content += f"""
output "{db['name']}_endpoint" {{
  description = "Endpoint of {db['name']}"
  value       = aws_db_instance.{db['name']}.endpoint
}}

"""

        return content

    def terraform_init(self) -> Tuple[bool, str]:
        """
        TerraformåˆæœŸåŒ–

        Returns:
            (success, output)
        """
        self.blackboard.log(
            "ğŸ”§ Initializing Terraform...",
            level="INFO",
            agent=AgentType.INFRASTRUCTURE_AS_CODE
        )

        try:
            result = subprocess.run(
                ["terraform", "init"],
                cwd=self.terraform_dir,
                capture_output=True,
                text=True,
                timeout=300
            )

            if result.returncode == 0:
                self.blackboard.log(
                    "âœ… Terraform initialized",
                    level="SUCCESS",
                    agent=AgentType.INFRASTRUCTURE_AS_CODE
                )
                return True, result.stdout
            else:
                self.blackboard.log(
                    f"âŒ Terraform init failed: {result.stderr}",
                    level="ERROR",
                    agent=AgentType.INFRASTRUCTURE_AS_CODE
                )
                return False, result.stderr

        except Exception as e:
            self.blackboard.log(
                f"âŒ Terraform init exception: {str(e)}",
                level="ERROR",
                agent=AgentType.INFRASTRUCTURE_AS_CODE
            )
            return False, str(e)

    def terraform_plan(self, output_file: Optional[str] = None) -> Tuple[bool, Dict]:
        """
        Terraform planã‚’å®Ÿè¡Œ

        Args:
            output_file: ãƒ—ãƒ©ãƒ³å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«

        Returns:
            (success, plan_summary)
        """
        self.blackboard.log(
            "ğŸ“‹ Running Terraform plan...",
            level="INFO",
            agent=AgentType.INFRASTRUCTURE_AS_CODE
        )

        try:
            cmd = ["terraform", "plan", "-json"]
            if output_file:
                cmd.extend(["-out", output_file])

            result = subprocess.run(
                cmd,
                cwd=self.terraform_dir,
                capture_output=True,
                text=True,
                timeout=300
            )

            if result.returncode == 0:
                # JSONãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ãƒ‘ãƒ¼ã‚¹
                plan_summary = self._parse_terraform_plan(result.stdout)

                self.blackboard.log(
                    f"âœ… Terraform plan complete: "
                    f"{plan_summary['resources_to_add']} to add, "
                    f"{plan_summary['resources_to_change']} to change, "
                    f"{plan_summary['resources_to_destroy']} to destroy",
                    level="SUCCESS",
                    agent=AgentType.INFRASTRUCTURE_AS_CODE
                )

                return True, plan_summary
            else:
                self.blackboard.log(
                    f"âŒ Terraform plan failed: {result.stderr}",
                    level="ERROR",
                    agent=AgentType.INFRASTRUCTURE_AS_CODE
                )
                return False, {"error": result.stderr}

        except Exception as e:
            self.blackboard.log(
                f"âŒ Terraform plan exception: {str(e)}",
                level="ERROR",
                agent=AgentType.INFRASTRUCTURE_AS_CODE
            )
            return False, {"error": str(e)}

    def _parse_terraform_plan(self, json_output: str) -> Dict:
        """Terraform planã®JSONå‡ºåŠ›ã‚’ãƒ‘ãƒ¼ã‚¹"""
        summary = {
            "resources_to_add": 0,
            "resources_to_change": 0,
            "resources_to_destroy": 0,
            "changes": []
        }

        try:
            for line in json_output.split('\n'):
                if not line.strip():
                    continue

                data = json.loads(line)

                if data.get("type") == "resource_drift":
                    summary["changes"].append({
                        "address": data.get("change", {}).get("resource", {}).get("addr"),
                        "action": data.get("change", {}).get("action")
                    })

                if data.get("type") == "change_summary":
                    summary["resources_to_add"] = data.get("changes", {}).get("add", 0)
                    summary["resources_to_change"] = data.get("changes", {}).get("change", 0)
                    summary["resources_to_destroy"] = data.get("changes", {}).get("remove", 0)

        except:
            pass

        return summary

    def terraform_apply(self, auto_approve: bool = False) -> Tuple[bool, str]:
        """
        Terraform applyã‚’å®Ÿè¡Œ

        Args:
            auto_approve: è‡ªå‹•æ‰¿èª

        Returns:
            (success, output)
        """
        self.blackboard.log(
            f"ğŸš€ Applying Terraform changes (auto_approve: {auto_approve})...",
            level="INFO",
            agent=AgentType.INFRASTRUCTURE_AS_CODE
        )

        try:
            cmd = ["terraform", "apply"]
            if auto_approve:
                cmd.append("-auto-approve")

            result = subprocess.run(
                cmd,
                cwd=self.terraform_dir,
                capture_output=True,
                text=True,
                timeout=600
            )

            if result.returncode == 0:
                self.blackboard.log(
                    "âœ… Terraform apply successful",
                    level="SUCCESS",
                    agent=AgentType.INFRASTRUCTURE_AS_CODE
                )
                return True, result.stdout
            else:
                self.blackboard.log(
                    f"âŒ Terraform apply failed: {result.stderr}",
                    level="ERROR",
                    agent=AgentType.INFRASTRUCTURE_AS_CODE
                )
                return False, result.stderr

        except Exception as e:
            self.blackboard.log(
                f"âŒ Terraform apply exception: {str(e)}",
                level="ERROR",
                agent=AgentType.INFRASTRUCTURE_AS_CODE
            )
            return False, str(e)

    def detect_drift(self) -> Tuple[bool, List[Dict]]:
        """
        ã‚¤ãƒ³ãƒ•ãƒ©ãƒ‰ãƒªãƒ•ãƒˆã‚’æ¤œçŸ¥

        Returns:
            (has_drift, drift_list)
        """
        self.blackboard.log(
            "ğŸ” Detecting infrastructure drift...",
            level="INFO",
            agent=AgentType.INFRASTRUCTURE_AS_CODE
        )

        try:
            # Terraform refresh ã§ãƒ‰ãƒªãƒ•ãƒˆæ¤œçŸ¥
            result = subprocess.run(
                ["terraform", "plan", "-detailed-exitcode", "-json"],
                cwd=self.terraform_dir,
                capture_output=True,
                text=True,
                timeout=300
            )

            # exit code 2 = changes detected
            has_drift = result.returncode == 2

            drift_list = []
            if has_drift:
                # ãƒ‰ãƒªãƒ•ãƒˆè©³ç´°ã‚’è§£æ
                plan_summary = self._parse_terraform_plan(result.stdout)
                drift_list = plan_summary.get("changes", [])

                self.blackboard.log(
                    f"âš ï¸ Drift detected: {len(drift_list)} resources",
                    level="WARNING",
                    agent=AgentType.INFRASTRUCTURE_AS_CODE
                )
            else:
                self.blackboard.log(
                    "âœ… No drift detected",
                    level="SUCCESS",
                    agent=AgentType.INFRASTRUCTURE_AS_CODE
                )

            # ãƒ¬ãƒãƒ¼ãƒˆä¿å­˜
            report = {
                "timestamp": datetime.now().isoformat(),
                "has_drift": has_drift,
                "drift_count": len(drift_list),
                "drifts": drift_list
            }

            report_file = self.reports_dir / f"drift_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            report_file.write_text(json.dumps(report, indent=2))

            return has_drift, drift_list

        except Exception as e:
            self.blackboard.log(
                f"âŒ Drift detection failed: {str(e)}",
                level="ERROR",
                agent=AgentType.INFRASTRUCTURE_AS_CODE
            )
            return False, []

    def detect_environment_diff(self, env1: str, env2: str) -> Dict:
        """
        ç’°å¢ƒé–“ã®å·®åˆ†ã‚’æ¤œå‡º

        Args:
            env1: ç’°å¢ƒ1 (e.g., "staging")
            env2: ç’°å¢ƒ2 (e.g., "production")

        Returns:
            å·®åˆ†ãƒ¬ãƒãƒ¼ãƒˆ
        """
        self.blackboard.log(
            f"ğŸ” Detecting differences between {env1} and {env2}...",
            level="INFO",
            agent=AgentType.INFRASTRUCTURE_AS_CODE
        )

        try:
            # å„ç’°å¢ƒã®Terraform stateã‚’å–å¾—
            state1 = self._get_terraform_state(env1)
            state2 = self._get_terraform_state(env2)

            # å·®åˆ†è¨ˆç®—
            diff_report = {
                "env1": env1,
                "env2": env2,
                "timestamp": datetime.now().isoformat(),
                "differences": []
            }

            # ãƒªã‚½ãƒ¼ã‚¹æ•°ã®å·®åˆ†
            resources1 = state1.get("resources", [])
            resources2 = state2.get("resources", [])

            resources1_names = set(r.get("name") for r in resources1)
            resources2_names = set(r.get("name") for r in resources2)

            only_in_env1 = resources1_names - resources2_names
            only_in_env2 = resources2_names - resources1_names

            if only_in_env1:
                diff_report["differences"].append({
                    "type": "missing_in_env2",
                    "resources": list(only_in_env1)
                })

            if only_in_env2:
                diff_report["differences"].append({
                    "type": "missing_in_env1",
                    "resources": list(only_in_env2)
                })

            self.blackboard.log(
                f"âœ… Environment diff complete: {len(diff_report['differences'])} differences",
                level="SUCCESS",
                agent=AgentType.INFRASTRUCTURE_AS_CODE
            )

            return diff_report

        except Exception as e:
            self.blackboard.log(
                f"âŒ Environment diff failed: {str(e)}",
                level="ERROR",
                agent=AgentType.INFRASTRUCTURE_AS_CODE
            )
            return {"error": str(e)}

    def _get_terraform_state(self, environment: str) -> Dict:
        """Terraform stateã‚’å–å¾—"""
        try:
            result = subprocess.run(
                ["terraform", "show", "-json"],
                cwd=self.terraform_dir,
                capture_output=True,
                text=True,
                timeout=60,
                env={**os.environ, "TF_WORKSPACE": environment}
            )

            if result.returncode == 0:
                return json.loads(result.stdout)
            return {}

        except:
            return {}

    def optimize_costs(self) -> Dict:
        """
        ã‚³ã‚¹ãƒˆæœ€é©åŒ–ææ¡ˆã‚’ç”Ÿæˆ

        Returns:
            æœ€é©åŒ–ãƒ¬ãƒãƒ¼ãƒˆ
        """
        self.blackboard.log(
            "ğŸ’° Analyzing cost optimization opportunities...",
            level="INFO",
            agent=AgentType.INFRASTRUCTURE_AS_CODE
        )

        try:
            # Terraform stateã‹ã‚‰ç¾åœ¨ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’å–å¾—
            result = subprocess.run(
                ["terraform", "show", "-json"],
                cwd=self.terraform_dir,
                capture_output=True,
                text=True,
                timeout=60
            )

            recommendations = []

            if result.returncode == 0:
                state = json.loads(result.stdout)
                resources = state.get("values", {}).get("root_module", {}).get("resources", [])

                for resource in resources:
                    resource_type = resource.get("type")
                    values = resource.get("values", {})

                    # EC2æœ€é©åŒ–
                    if resource_type == "aws_instance":
                        instance_type = values.get("instance_type")
                        if instance_type and instance_type.startswith("t2."):
                            recommendations.append({
                                "resource": resource.get("address"),
                                "type": "instance_type",
                                "current": instance_type,
                                "recommended": instance_type.replace("t2.", "t3."),
                                "reason": "T3 instances offer better performance/cost ratio",
                                "estimated_savings": "20-30%"
                            })

                    # RDSæœ€é©åŒ–
                    if resource_type == "aws_db_instance":
                        storage = values.get("allocated_storage")
                        if storage and storage > 100:
                            recommendations.append({
                                "resource": resource.get("address"),
                                "type": "storage",
                                "current": f"{storage}GB",
                                "recommended": "Enable autoscaling",
                                "reason": "Reduce over-provisioning",
                                "estimated_savings": "10-20%"
                            })

            optimization_report = {
                "timestamp": datetime.now().isoformat(),
                "recommendations_count": len(recommendations),
                "recommendations": recommendations,
                "total_estimated_savings": "15-25%"
            }

            self.blackboard.log(
                f"âœ… Cost optimization complete: {len(recommendations)} recommendations",
                level="SUCCESS",
                agent=AgentType.INFRASTRUCTURE_AS_CODE
            )

            return optimization_report

        except Exception as e:
            self.blackboard.log(
                f"âŒ Cost optimization failed: {str(e)}",
                level="ERROR",
                agent=AgentType.INFRASTRUCTURE_AS_CODE
            )
            return {"error": str(e)}

    def run_full_cycle(self, auto_apply: bool = False) -> Dict:
        """
        å®Œå…¨ãªIaCã‚µã‚¤ã‚¯ãƒ«ã‚’å®Ÿè¡Œ

        ãƒ•ãƒ­ãƒ¼:
        1. TerraformåˆæœŸåŒ–
        2. Planã®å®Ÿè¡Œ
        3. ãƒ‰ãƒªãƒ•ãƒˆæ¤œçŸ¥
        4. ã‚³ã‚¹ãƒˆæœ€é©åŒ–åˆ†æ
        5. (ã‚ªãƒ—ã‚·ãƒ§ãƒ³) Applyå®Ÿè¡Œ

        Returns:
            å®Ÿè¡Œãƒ¬ãƒãƒ¼ãƒˆ
        """
        report = {
            "started_at": datetime.now().isoformat(),
            "steps": [],
            "success": False
        }

        # Step 1: åˆæœŸåŒ–
        success, output = self.terraform_init()
        report["steps"].append({
            "step": "terraform_init",
            "success": success,
            "output": output if success else None
        })

        if not success:
            report["message"] = "Initialization failed"
            return report

        # Step 2: Planå®Ÿè¡Œ
        success, plan_summary = self.terraform_plan()
        report["steps"].append({
            "step": "terraform_plan",
            "success": success,
            "plan": plan_summary
        })

        # Step 3: ãƒ‰ãƒªãƒ•ãƒˆæ¤œçŸ¥
        has_drift, drift_list = self.detect_drift()
        report["steps"].append({
            "step": "detect_drift",
            "has_drift": has_drift,
            "drift_count": len(drift_list)
        })

        # Step 4: ã‚³ã‚¹ãƒˆæœ€é©åŒ–
        optimization = self.optimize_costs()
        report["steps"].append({
            "step": "optimize_costs",
            "success": "error" not in optimization,
            "optimization": optimization
        })

        # Step 5: Applyï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
        if auto_apply and success:
            success, output = self.terraform_apply(auto_approve=True)
            report["steps"].append({
                "step": "terraform_apply",
                "success": success,
                "output": output if success else None
            })

        report["completed_at"] = datetime.now().isoformat()
        report["success"] = True
        report["message"] = "Full IaC cycle completed"

        return report


# ã‚¹ã‚¿ãƒ³ãƒ‰ã‚¢ãƒ­ãƒ³å®Ÿè¡Œç”¨
if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Infrastructure as Code Agent")
    parser.add_argument("--repo", default=".", help="Repository path")
    parser.add_argument("--action", default="full",
                       choices=["generate", "init", "plan", "apply", "drift", "diff", "cost", "full"],
                       help="Action to perform")
    parser.add_argument("--auto-approve", action="store_true",
                       help="Auto-approve Terraform apply")

    args = parser.parse_args()

    agent = InfrastructureAsCodeAgent(args.repo)

    if args.action == "generate":
        resources = {
            "ec2_instances": [{"name": "web-server", "type": "t2.micro"}],
            "rds_databases": [{"name": "app-db", "engine": "postgres"}],
            "s3_buckets": [{"name": "app-storage"}]
        }
        success, path = agent.generate_terraform_config(resources)
        print(f"Generated: {success}")
        print(f"Path: {path}")

    elif args.action == "init":
        success, output = agent.terraform_init()
        print(f"Init: {success}")
        print(output)

    elif args.action == "plan":
        success, plan = agent.terraform_plan()
        print(f"Plan: {success}")
        print(json.dumps(plan, indent=2))

    elif args.action == "apply":
        success, output = agent.terraform_apply(auto_approve=args.auto_approve)
        print(f"Apply: {success}")
        print(output)

    elif args.action == "drift":
        has_drift, drifts = agent.detect_drift()
        print(f"Has drift: {has_drift}")
        print(json.dumps(drifts, indent=2))

    elif args.action == "diff":
        diff = agent.detect_environment_diff("staging", "production")
        print(json.dumps(diff, indent=2))

    elif args.action == "cost":
        optimization = agent.optimize_costs()
        print(json.dumps(optimization, indent=2))

    elif args.action == "full":
        report = agent.run_full_cycle(auto_apply=args.auto_approve)
        print(json.dumps(report, indent=2))
